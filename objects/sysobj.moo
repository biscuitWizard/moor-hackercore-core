object #0
  name: "The System Object"
  owner: #2
  readable: true

  property ambiguous_match (owner: #2, flags: "r") = #-2;
  property ansi (owner: #2, flags: "r") = #25;
  property big_mail_recipient (owner: #2, flags: "r") = #14;
  property biglist (owner: #2, flags: "r") = #13;
  property builder (owner: #2, flags: "r") = #4;
  property building_utils (owner: #2, flags: "r") = #21;
  property class_registry (owner: #2, flags: "r") = {
    {
      "generics",
      "Generic objects intended for use as the parents of new objects",
      {#3, #7, #5, #9, #54, #8, #1, #6, #58, #57, #50, #45, #46},
      #4
    },
    {
      "utilities",
      "Objects holding useful general-purpose verbs",
      {
        #20,
        #55,
        #24,
        #27,
        #41,
        #26,
        #43,
        #51,
        #52,
        #53,
        #56,
        #42,
        #21,
        #33,
        #13,
        #79,
        #81,
        #59,
        #91,
        #93,
        #99,
        #122,
        #125,
        #75
      },
      #58
    },
    {
      "server",
      "Objects containing functionality that affects the server.",
      {#64, #82, #97},
      #57
    },
    {
      "prototypes",
      "Objects containing verbs that can be called on their corresponding types.",
      {#117, #119, #115, #114, #111},
      #58
    }
  };
  property code_scanner (owner: #2, flags: "r") = #95;
  property code_utils (owner: #2, flags: "r") = #59;
  property command_utils (owner: #2, flags: "r") = #56;
  property container (owner: #2, flags: "r") = #8;
  property convert_utils (owner: #2, flags: "r") = #93;
  property cu (owner: #2, flags: "r") = #56;
  property datastore (owner: #2, flags: "r") = #37;
  property diff_utils (owner: #2, flags: "r") = #96;
  property edit_session (owner: #2, flags: "r") = #126;
  property edit_state (owner: #2, flags: "r") = #124;
  property edit_utils (owner: #2, flags: "r") = #122;
  property error (owner: #2, flags: "r") = #69;
  property exit (owner: #2, flags: "r") = #7;
  property failed_match (owner: #2, flags: "r") = #-3;
  property false (owner: #2, flags: "r") = 0;
  property feature (owner: #2, flags: "r") = #74;
  property feature_warehouse (owner: #2, flags: "r") = #83;
  property frobs (owner: #2, flags: "r") = {};
  property garbage (owner: #2, flags: "r") = #49;
  property gender_utils (owner: #2, flags: "r") = #41;
  property gendered_object (owner: #2, flags: "r") = #94;
  property generic_help (owner: #2, flags: "r") = #30;
  property generic_options (owner: #2, flags: "r") = #68;
  property generic_utils (owner: #2, flags: "r") = #78;
  property guest (owner: #2, flags: "r") = #31;
  property guest_log (owner: #2, flags: "r") = #12;
  property hacker (owner: #2, flags: "r") = #36;
  property help (owner: #2, flags: "r") = #97;
  property int_proto (owner: #2, flags: "r") = #116;
  property last_huh (owner: #2, flags: "r") = #11;
  property limbo (owner: #2, flags: "r") = #15;
  property list_proto (owner: #2, flags: "r") = #115;
  property list_utils (owner: #2, flags: "r") = #55;
  property lock_utils (owner: #2, flags: "r") = #53;
  property login (owner: #2, flags: "r") = #10;
  property lu (owner: #2, flags: "r") = #55;
  property map_proto (owner: #2, flags: "r") = #117;
  property match_utils (owner: #2, flags: "r") = #51;
  property math_utils (owner: #2, flags: "r") = #26;
  property matrix_utils (owner: #36, flags: "r") = #91;
  property maxint (owner: #2, flags: "r") = 9223372036854775807;
  property mcp (owner: #2, flags: "r") = #110;
  property menu_utils (owner: #2, flags: "r") = #125;
  property minint (owner: #2, flags: "r") = -9223372036854775807;
  property mu (owner: #2, flags: "r") = #26;
  property network (owner: #2, flags: "r") = #72;
  property news (owner: #2, flags: "r") = #61;
  property no_one (owner: #2, flags: "r") = #38;
  property nothing (owner: #2, flags: "r") = #-1;
  property obj_proto (owner: #2, flags: "r") = #111;
  property object_utils (owner: #2, flags: "r") = #52;
  property options (owner: #2, flags: "r") = [
    "ansi" -> #102,
    "build" -> #77,
    "display" -> #67,
    "edit" -> #66,
    "mail" -> #65,
    "prog" -> #76
  ];
  property ou (owner: #2, flags: "r") = #52;
  property pasting_feature (owner: #2, flags: "r") = #90;
  property perm_utils (owner: #2, flags: "r") = #42;
  property player (owner: #2, flags: "r") = #6;
  property player_class (owner: #2, flags: "r") = #6;
  property player_start (owner: #2, flags: "r") = #62;
  property prog (owner: #2, flags: "r") = #58;
  property proto (owner: #2, flags: "r") = #114;
  property recycler (owner: #2, flags: "r") = #47;
  property recycling_pool (owner: #2, flags: "r") = #48;
  property room (owner: #2, flags: "r") = #3;
  property root_class (owner: #2, flags: "r") = #1;
  property seq_utils (owner: #2, flags: "r") = #33;
  property server (owner: #2, flags: "r") = [
    "core_history" -> {
      {"HackerCore", "2.7.2", 1721211497},
      {"ToastCore", "2.7.1", 1713940026},
      {"a 2018 LambdaCore", "2.6.0", 1576791887}
    },
    "last_restart_time" -> 1758800578,
    "name" -> "LambdaMOO-ToastStunt",
    "shutdown_time" -> 0
  ];
  property server_options (owner: #2, flags: "r") = #82;
  property set_utils (owner: #2, flags: "r") = #27;
  property shapes (owner: #2, flags: "r") = #75;
  property singleton (owner: #2, flags: "r") = #17;
  property singleton_warehouse (owner: #2, flags: "r") = #84;
  property spell (owner: #2, flags: "r") = #32;
  property str_proto (owner: #2, flags: "r") = #119;
  property string_utils (owner: #2, flags: "r") = #20;
  property su (owner: #2, flags: "r") = #20;
  property sysobj (owner: #2, flags: "r") = #0;
  property telnet (owner: #2, flags: "r") = #64;
  property thing (owner: #2, flags: "r") = #5;
  property time_utils (owner: #2, flags: "r") = #43;
  property trig_utils (owner: #2, flags: "r") = #26;
  property true (owner: #2, flags: "r") = 1;
  property vms (owner: #2, flags: "r") = #9;
  property wiz (owner: #2, flags: "r") = #57;
  property wiz_utils (owner: #2, flags: "r") = #24;
  property you (owner: #36, flags: "r") = #35;

  verb do_login_command (this none this) owner: #2 flags: "rxd"
    "...This code should only be run as a server task...";
    if (callers())
      return E_PERM;
    endif
    if (typeof(h = $network:incoming_connection(player)) == OBJ)
      "connected to an object";
      return h;
    elseif (h)
      return 0;
    endif
    "...checks to see if the login is spamming the server with too many commands...";
    if (!$login:maybe_limit_commands())
      args = $login:parse_command(@args);
      return $login:((args[1]))(@listdelete(args, 1));
    endif
  endverb

  verb server_started (this none this) owner: #2 flags: "rxd"
    if (callers())
      raise(E_PERM, tostr(verb, " can only be called by the server daemon."));
    endif
    $server["last_restart_time"] = time();
    "call on_server_started hook for mortal objects";
    for object in ({$root_class, @$ou:descendants($root_class)})
      hook_verb_info = `verb_info(object, "on_server_started") ! ANY => {}';
      if (!hook_verb_info || !("x" in hook_verb_info[2]))
        "verb does not exist or is not callable";
        continue;
      elseif (!hook_verb_info[1].wizard)
        "insufficient permissions; hook must be owned by wizardly account.";
        continue;
      endif
      object:on_server_started();
    endfor
  endverb

  verb "user_created user_connected" (this none this) owner: #2 flags: "rxd"
    "Copied from The System Object (#0):user_connected by Slartibartfast (#4242) Sun May 21 18:14:16 1995 PDT";
    if (callers())
      return;
    endif
    "commented out as moor may handle sessions";
    "$mcp:(verb)(@args)";
    user = args[1];
    set_task_perms(user);
    try
      user.location:confunc(user);
      user:confunc();
    except id (ANY)
      user:tell("Confunc failed: ", id[2], ".");
      for tb in (id[4])
        user:tell("... called from ", tb[4], ":", tb[2], tb[4] != tb[1] ? tostr(" (this == ", tb[1], ")") | "", ", line ", tb[6]);
      endfor
      user:tell("(End of traceback)");
    endtry
  endverb

  verb "user_disconnected user_client_disconnected" (this none this) owner: #2 flags: "rxd"
    if (callers())
      return;
    endif
    if (args[1] < #0)
      "not logged in user.  probably should do something clever here involving Carrot's no-spam hack.  --yduJ";
      "...'forget' that we already performed a name lookup on this connection...";
      $login:delete_name_lookup(args[1]);
      return;
    endif
    $mcp:(verb)(@args);
    user = args[1];
    user.last_disconnect_time = time();
    set_task_perms(user);
    where = user.location;
    `user:disfunc() ! ANY => 0';
    if (user.location != where)
      `where.location:disfunc(user) ! ANY => 0';
    endif
    `user.location:disfunc(user) ! ANY => 0';
  endverb

  verb "bf_chparent chparent" (this none this) owner: #2 flags: "rxd"
    "chparent(object, new-parent) -- see help on the builtin.";
    who = caller_perms();
    {what, papa} = args;
    if (typeof(what) != OBJ)
      retval = E_TYPE;
    elseif (!valid(what))
      retval = E_INVARG;
    elseif (typeof(papa) != OBJ)
      retval = E_TYPE;
    elseif (!valid(papa) && papa != #-1)
      retval = E_INVIND;
    elseif (!$perm_utils:controls(who, what))
      retval = E_PERM;
    elseif (is_player(what) && !$object_utils:isa(papa, $player_class) && !who.wizard)
      retval = E_PERM;
    elseif (is_player(what) && !$object_utils:isa(what, $player_class) && !who.wizard)
      retval = E_PERM;
    elseif (children(what) && $object_utils:isa(what, $player_class) && !$object_utils:isa(papa, $player_class))
      retval = E_PERM;
    elseif (is_player(what) && what in $wiz_utils.chparent_restricted && !who.wizard)
      retval = E_PERM;
    elseif (what.location == $mail_agent && $object_utils:isa(what, $mail_recipient) && !$object_utils:isa(papa, $mail_recipient) && !who.wizard)
      retval = E_PERM;
    elseif (!valid(papa) || ($perm_utils:controls(who, papa) || papa.f))
      retval = `chparent(@args) ! ANY';
    else
      retval = E_PERM;
    endif
    return typeof(retval) == ERR && $code_utils:dflag_on() ? raise(retval) | retval;
  endverb

  verb "bf_add_verb add_verb" (this none this) owner: #2 flags: "rxd"
    "add_verb() -- see help on the builtin for more information. This verb is called by the server when $server_options.protect_add_verb exists and is true and caller_perms() are not wizardly.";
    who = caller_perms();
    what = args[1];
    info = args[2];
    if (typeof(what) != OBJ)
      retval = E_TYPE;
    elseif (!valid(what))
      retval = E_INVARG;
    elseif (!$perm_utils:controls(who, what) && !what.w)
      "caller_perms() is not allowed to hack on the object in question";
      retval = E_PERM;
    elseif (!$perm_utils:controls(who, info[1]))
      "caller_perms() is not permitted to add a verb with the specified owner.";
      retval = E_PERM;
    elseif (index(info[2], "w") && !$server_options.permit_writable_verbs)
      retval = E_INVARG;
    elseif (what.owner != who && !who.wizard)
      retval = E_QUOTA;
    elseif (!who.programmer)
      retval = E_PERM;
    else
      "we now know that the caller's perms control the object or the object is writable, and we know that the caller's perms control the prospective verb owner (by more traditional means)";
      retval = `add_verb(@args) ! ANY';
    endif
    return typeof(retval) == ERR && $code_utils:dflag_on() ? raise(retval) | retval;
  endverb

  verb "bf_add_property add_property" (this none this) owner: #2 flags: "rxd"
    "add_property() -- see help on the builtin for more information. This verb is called by the server when $server_options.protect_add_property exists and is true and caller_perms() are not wizardly.";
    who = caller_perms();
    {what, propname, value, info} = args;
    if (typeof(what) != OBJ)
      retval = E_TYPE;
    elseif (!valid(what))
      retval = E_INVARG;
    elseif (!$perm_utils:controls(who, what) && !what.w)
      retval = E_PERM;
    elseif (!$perm_utils:controls(who, info[1]))
      retval = E_PERM;
    else
      "we now know that the caller's perms control the object (or the object is writable), and that the caller's perms are permitted to control the new property's owner.";
      retval = `add_property(@args) ! ANY';
    endif
    return typeof(retval) == ERR && $code_utils:dflag_on() ? raise(retval) | retval;
  endverb

  verb "bf_recycle recycle" (this none this) owner: #2 flags: "rxd"
    "recycle(object) -- see help on the builtin. This verb is called by the server when $server_options.protect_recycle exists and is true and caller_perms() are not wizardly.";
    {what} = args;
    if (!valid(what))
      retval = E_INVARG;
    elseif (!$perm_utils:controls(who = caller_perms(), what))
      retval = E_PERM;
    elseif ((p = `is_player(what) ! E_TYPE => 0') && !who.wizard)
      for p in ($wiz_utils:connected_wizards_unadvertised())
        p:tell($string_utils:pronoun_sub("%N (%#) is currently trying to destroy %t (%[#t])", who, what));
      endfor
      retval = E_PERM;
    else
      if (p)
        $wiz_utils:unset_player(what);
      endif
      $recycler:kill_all_tasks(what);
      retval = `recycle(what) ! ANY';
    endif
    return typeof(retval) == ERR && $code_utils:dflag_on() ? raise(retval) | retval;
  endverb

  verb user_reconnected (this none this) owner: #2 flags: "rxd"
    if (callers())
      return;
    endif
    $mcp:(verb)(@args);
    if ($object_utils:isa(user = args[1], $guest))
      "from $guest:boot";
      oldloc = user.location;
      move(user, $nothing);
      "..force enterfunc to be called so that the newbie gets a room description.";
      move(user, user.home);
      user:do_reset();
      if ($object_utils:isa(oldloc, $room))
        oldloc:announce("In the distance you hear someone's alarm clock going off.");
        if (oldloc != user.location)
          oldloc:announce(user.name, " wavers and vanishes into insubstantial mist.");
        else
          oldloc:announce(user.name, " undergoes a wrenching personality shift.");
        endif
      endif
      set_task_perms(user);
      `user:confunc() ! ANY';
    else
      set_task_perms(user);
      `user:reconfunc() ! ANY';
    endif
  endverb

  verb "bf_set_verb_info set_verb_info" (this none this) owner: #2 flags: "rxd"
    "set_verb_info() -- see help on the builtin for more information. This verb is called by the server when $server_options.protect_set_verb_info exists and is true and caller_perms() are not wizardly.";
    {o, v, i} = args;
    if (typeof(vi = `verb_info(o, v) ! ANY') == ERR)
      "probably verb doesn't exist";
      retval = vi;
    elseif (!$perm_utils:controls(cp = caller_perms(), vi[1]))
      "perms don't control the current verb owner";
      retval = E_PERM;
    elseif (typeof(i) != LIST || typeof(no = i[1]) != OBJ)
      "info is malformed";
      retval = E_TYPE;
    elseif (!valid(no) || !is_player(no))
      "invalid new verb owner";
      retval = E_INVARG;
    elseif (!$perm_utils:controls(cp, no))
      "perms don't control prospective verb owner";
      retval = E_PERM;
    elseif (index(i[2], "w") && !`$server_options.permit_writable_verbs ! E_PROPNF, E_INVIND => 1')
      retval = E_INVARG;
    else
      retval = `set_verb_info(o, v, i) ! ANY';
    endif
    return typeof(retval) == ERR && $code_utils:dflag_on() ? raise(retval) | retval;
  endverb

  verb "bf_match match" (this none this) owner: #2 flags: "rxd"
    m = `match(@args) ! ANY';
    return typeof(m) == ERR && $code_utils:dflag_on() ? raise(m) | m;
  endverb

  verb "bf_rmatch rmatch" (this none this) owner: #2 flags: "rxd"
    r = `rmatch(@args) ! ANY';
    return typeof(r) == ERR && $code_utils:dflag_on() ? raise(r) | r;
  endverb

  verb "do_out_of_band_command doobc" (this none this) owner: #2 flags: "rxd"
    "do_out_of_band_command -- a cheap and very dirty do_out_of_band verb.  Forwards to verb on player with same name if it exists, otherwise forwards to $login.  May only be called by the server in response to an out of band command, otherwise E_PERM is returned.";
    if (caller == #-1 && caller_perms() == #-1 && callers() == {})
      if (valid(player) && is_player(player))
        $mcp:(verb)(@args);
        set_task_perms(player);
        $object_utils:has_callable_verb(player, "do_out_of_band_command") && player:do_out_of_band_command(@args);
      elseif ($telnet:(verb)(@args))
        return;
      else
        $login:do_out_of_band_command(@args);
      endif
    else
      return E_PERM;
    endif
  endverb

  verb handle_uncaught_error (this none this) owner: #2 flags: "rxd"
    if (!callers())
      {code, msg, value, stack, traceback} = args;
      if (!$object_utils:connected(player))
        "Mail the player the traceback if e isn't connected.";
        $mail_agent:send_message(#0, player, {"traceback", $wiz_utils.gripe_recipients}, traceback);
      endif
      "now let the player do something with it if e wants...";
      return `player:(verb)(@args) ! ANY';
    endif
  endverb

  verb bf_force_input (this none this) owner: #2 flags: "rxd"
    "Copied from Jay (#3920):bf_force_input Mon Jun 16 20:55:27 1997 PDT";
    "force_input(conn, line [, at-front])";
    "see help on the builtin for more information. This verb is called by the server when $server_options.protect_force_input exists and is true and caller_perms() are not wizardly.";
    {conn, line, ?at_front = 0} = args;
    if (caller_perms() != conn)
      retval = E_PERM;
    elseif (conn in $login.newted)
      retval = E_PERM;
    else
      retval = `force_input(@args) ! ANY';
    endif
    return typeof(retval) == ERR && $code_utils:dflag_on() ? raise(retval) | retval;
  endverb

  verb moveto (this none this) owner: #2 flags: "rxd"
    "Let's keep bozos from partying.  --Nosredna the partypooper";
    return pass(#-1);
  endverb

  verb "bf_set_property_info set_property_info" (this none this) owner: #2 flags: "rxd"
    who = caller_perms();
    retval = 0;
    try
      {what, propname, info} = args;
    except (E_ARGS)
      retval = E_ARGS;
    endtry
    try
      {owner, perms, ?newname = 0} = info;
    except (E_ARGS)
      retval = E_ARGS;
    except (E_TYPE)
      retval = E_TYPE;
    endtry
    if (retval != 0)
    elseif (newname in {"object_size", "size_quota", "queued_task_limit"} && !who.wizard)
      retval = E_PERM;
    else
      set_task_perms(who);
      retval = `set_property_info(@args) ! ANY';
    endif
    return typeof(retval) == ERR && $code_utils:dflag_on() ? raise(retval) | retval;
  endverb

  verb handle_task_timeout (this none this) owner: #2 flags: "rxd"
    if (!callers())
      {resource, stack, traceback} = args;
      if (!$object_utils:connected(player))
        "Mail the player the traceback if e isn't connected.";
        $mail_agent:send_message(#0, player, {"traceback", $wiz_utils.gripe_recipients}, traceback);
      endif
      "now let the player do something with it if e wants...";
      return `player:(verb)(@args) ! ANY';
    endif
  endverb

  verb bf_read (this none this) owner: #2 flags: "rxd"
    set_task_perms(caller_perms());
    `player.reading_input = 1 ! E_PROPNF, E_INVIND';
    input = `read(@args) ! ANY';
    `clear_property(player, "reading_input") ! E_PROPNF, E_INVARG';
    return typeof(input) == ERR && $code_utils:dflag_on() ? raise(input) | input;
  endverb

  verb "bf_chparents chparents" (this none this) owner: #2 flags: "rxd"
    who = caller_perms();
    {what, papas, ?anon_kids = {}} = args;
    if (typeof(what) != OBJ)
      retval = E_TYPE;
    elseif (!valid(what))
      retval = E_INVARG;
    elseif (typeof(papas) != LIST)
      retval = E_TYPE;
    elseif (!$perm_utils:controls(who, what))
      retval = E_PERM;
    elseif (is_player(what) && !occupants(papas, $player_class) && !who.wizard)
      retval = E_PERM;
    elseif (children(what) && $object_utils:isa(what, $player_class) && !occupants(papas, $player_class))
      retval = E_PERM;
    elseif (is_player(what) && what in $wiz_utils.chparent_restricted && !who.wizard)
      retval = E_PERM;
    elseif (what.location == $mail_agent && $object_utils:isa(what, $mail_recipient) && !$object_utils:isa(papa, $mail_recipient) && !who.wizard)
      retval = E_PERM;
    else
      for x in (papas)
        if (!$perm_utils:controls(who, x) && !x.f)
          retval = E_PERM;
          break;
        endif
      endfor
      if (`typeof(retval) ! ANY => 0' != ERR)
        retval = `chparents(@args) ! ANY';
      endif
    endif
    return typeof(retval) == ERR && $code_utils:dflag_on() ? raise(retval) | retval;
  endverb
endobject
